//https://e-maxx.ru/algo/segment_tree подробнее тут про каждую функцию
//---------------------------------------
#define left(v) v + v
#define right(v) v + v + 1
//----------------------------------------
ll n, q, tp, a[N], t[4 * N];
//-----------------------------------------
void recalc(ll v) {
    t[v] = t[left(v)] + t[right(v)]; //изменяешь условия recalc зависимости от задачи (тут представлено сумма) 
}
//Процедура построения дерева отрезков по заданному массиву a[] выглядит следующим образом: это рекурсивная функция, ей передаётся номер v текущей вершины дерева, и границы tl и tr отрезка, соответствующего текущей вершине дерева. Из основной программы вызывать эту функцию следует с параметрами v=1, tl=0, tr=n-1.
void build(ll v, ll tl, ll tr) { 
    if(!(tr - tl)) { t[v] = a[tl]; return; }
    ll tm = (tl + tr) / 2;
    build(left(v), tl, tm);
    build(right(v), tm + 1, tr);
    recalc(v);
}
/* функция для запроса суммы представляет из себя также рекурсивную функцию, которой таким же образом передаётся информация о текущей вершине дерева (т.е. числа v, tl, tr, которым в основной программе следует передавать значения 1, 0, n-1 соответственно), а помимо этого — также границы l и r текущего запроса. В целях упрощения кода эта фукнция всегда делает по два рекурсивных вызова, даже если на самом деле нужен один — просто лишнему рекурсивному вызову передастся запрос, у которого l > r, что легко отсекается дополнительной проверкой в самом начале функции.*/
ll get(ll v, ll tl, ll tr, ll l, ll r) { //
    if(l <= tl && tr <= r) return t[v];
    if(tr < l || r < tl) return 0;
    ll tm = (tl + tr) / 2;
    return get(left(v), tl, tm, l, r) + get(right(v), tm + 1, tr, l, r);
}
//запрос модификации. Ему точно так же передаётся информация о текущей вершине дерева отрезков, а дополнительно указывается индекс меняющегося элемента, а также его новое значение.
void upd(ll v, ll tl, ll tr, ll i, ll x) {
    if(!(tl - tr)) { t[v] = x; return; }
    ll tm = (tl + tr) / 2;
    if(i <= tm) upd(left(v), tl, tm, i, x);
    else upd(right(v), tm + 1, tr, i, x);
    recalc(v);
}
//-----------------------------------------------------------------------
   //ввод
   build(1, 0, n - 1);
   //запросы
